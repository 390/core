GENERAL
=======
- The format of config.php has changed, please manually complete the values in
  the supplied config.php - note that base64 encoding is not supposed any more
  and everything must be in plain text (this is because base64 encoding is not
  actually an encryption).

TEMPLATES
=========
- Change all module templates plugin delimiters to { and }.  For any template
  plugins inside a <script></script> block or a <style></style> block please
  use {{ and }}.

- All plugins with pn have been renamed without the pn prefix.  The pndebug
  plugin has been renamed to zdebug. See all deprecated template plugins in
  lib/legacy/pluginsPlease adjust your templates accordingly.

- To accommodate easy transition to the new templates Zikula runs a prefilter
  that will convert the old delimiters to the new, and also remove the pn prefix
  from any template plugin calls.  This will also affect 3rd party module so
  3rd party modules must drop their pn prefix from the actual plugins.  As a
  workaround you can copy the plugin file and rename it and the function inside
  without the prefix.

- The {gt} plugin now no longer requires domain="", this will be detected automatically.

- You must refactor templates using the 'pndate_format' modifier to 'dateformat'.

- Output filtering is now done with safetext, and safehtml modifiers.

- All use of pnML() and {ml} are both completely deprecated and will not work
  any more because Zikula no longer supports define based language packs.
  Upgrade themes and modules to use Gettext.

- Rename templates from *.htm to *.tpl

- If you need to make browser hack please use the block made for the case, e.g.
  {browserhack condition="if lte IE 7"}foo{/browserback}
  This block also takes assign="var" so you can assign rather than display.

- Remove {addition_headers} plugin from any themes, this doesn't work anymore.

- Replace all occurrences of "javascript/style.css" with "styles/core.css"

- The {pager} plugin  no longer requires the parameter shift 

MODULES
=======
- Module folder structure has changed, please create lib/$modname inside the module
  folder.  e.g. in module MyModule, add lib/MyModule.

    The old ones are still backward compatible but since file scanning is used
    your modules will be more efficient if you change to this format.

    - Rename pndocs to docs
    - Rename pnincludes to lib/, or lib/vendor if specifying 3rd party libs
    - Rename pnstyle to style
    - Rename pnjavascript to javascript
    - Rename pntemplates to templates

- Rename pntables.php to tables.php.  Change the function inside to $modulename_tables()

- Module folders now MUST start with a capital letter.

- Rename pnversion.php to lib/MyModule/Version.php
  Edit the contents like so:

    class MyModule_Version extends Zikula_Version
    {
        public function getMetaData()
        {
            $meta = array();
            $meta['displayname']    = $this->__('MyModule example');
            $meta['description']    = $this->__("Example MyModule description.");
            //! module name that appears in URL
            $meta['url']            = $this->__('mymodule');
            $meta['version']        = '1.5.3';
            $meta['capabilities']   = array('profile' => array('version' => '1.0'));
            $meta['contact']        = 'http://zikula.org/';

            $meta['securityschema'] = array('MyModule::' => '::');
            return $meta;
        }
    }

  NOTE: Version numbers must be in the form 'a.b.c' e.g '1.0.0'

  Notice the new capabilities key.  This is an indexed array of arrays.
  array('profile' => array('version' => '1.0', 'anotherkey' => 'anothervalue')
        'message' => array('version' => '1.0', 'anotherkey' => 'anothervalue'));

  The following APIs can be used
    ModUtil::getModulesCapableOf()
    ModUtil::isCapable()
    ModUtil::getCapabilitiesOf()
    {html_select_modules capability='...'}

(Note in the following examples, $type must always start with a capital letter
 and all remaining characters must be lower case).

- Move module controllers (pnuser.php, pnadmin.php etc) to lib/$modname/Controller/$type
  e.g.
    pnuser.php => lib/MyModule/Controller/User.php

  Refactor the controllers, encapulating all functions inside 
  class $modname_Controller_$type extends Zikula_Controller
  e.g.
    class MyModule_Controller_User extends Zikula_Controller

  Make all functions public which should be accessible from the browser.
  Internal methods which should not be accessible outside the class should be made
  protected or private.  If you subclass Zikula_Controller, inherited methods
  will not be accessible even if they are public.

- Move module APIs (pnuserapi.php, pnadminapi.php etc) to lib/$modname/Api/$type
  e.g.
    pnuserapi.php => lib/MyModule/Api/User.php

  Refactor the APIs, encapulating all functions inside 
  class $modname_Api_$type extends Zikula_Api
  e.g.
    class MyModule_Api_User extends Zikula_Api

  Make all functions public which should be accessible from ModUtil::apiFunc().
  Internal methods which should not be accessible outside the class should be made
  protected or private.

- Move module blocks (pnblocks/foo.php etc) to lib/$modname/$type
  e.g.
    blocks/foo.php => lib/MyModule/Block/Foo.php

  Refactor the Blocks, encapulating all functions inside 
  class $modname_block_$type extends Zikula_Block
  e.g.
    class MyModule_Block_Foo extends Zikula_Block

  Make all functions public which should be accessible from outside the class.
  Internal methods which should not be accessible outside the class should be made
  protected or private.

- For all Controllers, APIs and Blocks, change gettext function calls
  OO modulea now have access to convenience where the domain is calculated
  automatically.

    $this->__($msgid)
    $this->__f($msgid, $params)
    $this->_n($singular, $plural, $count)
    $this->_fn($sin, $plu, $n, $params)

  Remove any $dom = ZLanguage::getModuleDomain() calls except from version.php

- For all Controllers and Blocks, remove any pnRender::getInstance() calls entirely.
  $this->view is automatically available: $this->view->assign(), $this->view->fetch()
  etc.

- Rename and move pninit.php to lib/MyModule/Installer.php
  Encapulate all functions in class $modname extends Zikula_Installer
  e.g.
    class MyModule_Installer extends Zikula_Installer
  
  Rename init() to install().
  Rename delete() to uninstall().

  Make all function public except for internal ones which should not be accessible outside the class,
  in which case make the protected or private.  Generally speaking only
  install(), upgrade() and uninstall() should be public.

  If you module was not compliant with previous standards you must
  - Add $meta['oldnames'] = array(oldnames,....); // in Version.php
  - Migrate any modvars with

        $modvars = ModUtil::getVar($oldname);
        if ($modvars) {
            foreach ($modvars as $key => $value) {
                $this->setVar($key, $value);
            }
            ModUtil::delVar($oldname);
        }

- Interactive install/upgrade/uninstall
  If there are any interactive install methods, please add these to lib/$modname/Controller/Interactiveinstaller.php
  e.g.
    lib/MyModule/Controller/Interactiveinstaller.php
    contains class MyModule_Controller_Interactiveinstaller extends Zikula_InteractiveInstaller (notice the casing).

  Basically, if the interactive installers has method install() that will override the install() in
  the main Installer.php, if it has upgrade() it will override the main upgrade() and if it has
  uninstall() it will override the uninstall() method.  Note, the override happen only at
  the initial install, upgrade, uninstall process when the user clicks to install/upgrade/uninstall.
  At the laste step, of the interactive process the installer will invoke the Installer.php methods to
  do the actual final process.

  Subsequent steps can be named arbitarily in the interactive installer controller class.  For example you might have
  upgrade_step1()
  upgrade_step2()
  etc.

  For security reasons, when an interactive process starts, a session variable is set called 'interactive_process'.
  When the interactive installer process finishes, either successfully, or because of an error please make sure
  to delete this with SessionUtil::delVar('interactive_process');

- If you need any bootstrapping, like making a library available create bootstrap.php, this is
  included when the Module is first 'loaded'.

- If you use categorisation please refactor to use the following classes:
    PNCategory => Categories_DBObject_Category
    PNCategoryArray => Categories_DBObject_CategoryArray
    PNCategoryRegistry => Categories_DBObject_Registry
    PNCategoryRegistryArray => Categories_DBObject_RegistryArray

    Remove all references to Loader::loadClassFromModule, Loader::loadClassFromModuleArray()

- Remove any references to Loader::loadClass() - classes are loaded automatically.

- You may now use the following convenience methods from OO controllers and APIs.
    (see lib/Zikula/Base.php for details)

    $this->throwNotFound()
    $this->throwNotFoundIf()
    $this->throwNotFoundUnless()

    $this->throwForbidden()
    $this->throwForbiddenIf()
    $this->throwForbiddenUnless()

    $this->redirect()
    $this->redirectIf()
    $this->redirectUnless()

- In OO modules, please refactor ModUtil::callHooks() to $this->callHooks().  This
  adds $subject and $args to the hook calls.  $subject defaults to $this.

- ModUtil::callHooks(), added $subject and $args params. In non OO modules please
  add a these to your module/template hook calls where $subject could be the
  controller for example $this, or inside a template, $controller.
  The $args that hook methods receive will now contain the extra keys 'subject'
  and 'args'.  These correspond to the $subject and $args passed to ModUtil::callHooks()


DBOBJECT
========
- Rename classes to $modname_DBObject_$type and move to lib/$modname/DBObject/$type.php
  e.g
    MyModule_DBObject_Payments and move to lib/MyModule/DBObject/Payments.php
    MyModule_DBObject_PaymentsArray and move to lib/MyModule/DBObject/PaymentsArray.php

- Change the constructor of your DBObjects (was PNObject)
  from ClassName() to __construct() and to invoke parent constructor
  change $this->PNObject() to parent::__construct().

- Do not use Loader::loadClassFromModule to get DBObject class names any more.
  Simply build the class name or hard code it.

DBUTIL
======
- DBUtil::executeSQL used to return a ADODB object but now returns a PHP PDO
  object.  This means any code that previously iterated on the ADODB object
  will now break.  Please use of DBUtil::marshallObjects() after any manual
  SELECT through DBUtil::executeSQL() e.g.:

    [php]
    $res = DBUtil::executeSql ($sql);
    $objectArray = DBUtil::marshallObjects ($res, $ca, ...);

  Alternatively you can use the PDO return object.  PDO is built into PHP so
  accessing the PDO object is considered API complaint.  PDO documentation is
  available at http://php.net/PDO


MISCELLANEOUS
=============
- Theme module APIs theme_userapi_clear_compiled(), theme_userapi_clear_cache(),
  and pnrender_userapi_clear_compiled(), pnrender_userapi_clear_cache() are
  deprecated.  Please use Zikula_View::clear_compiled(), Zikula_View::clear_cache() and
  Theme::clear_compiled(), Theme::clear_cache().

- Now you can add a requirement check for your blocks which will display a
  message if it's necessary into the admin panel. eg: the language block will be
  visible only if the multilanguage system is enabled, so for this block a
  requirement message was aded to inform the admin that this block will not be
  visible until he enables the multilanguage system.

- You may now customise the core with Event Handler, these can be loaded in
  config/EventHandlers.  The classes should be the same as the filename and
  extend from CustomEventHandler.

- In modules you can autoload event handlers by calling
  EventManagerUtil::attachCustomHandlers($path) which should be a folder with
  just event handlers, or if you have static method handler just load them
  directly with EventManagerUtil::attach($name, $callable) [see ** below]
  This method could be used to load event handler dynamically from a ConfigVar()
  containing array('name' => $name, 'callable' => $callable);

  ** Note that a callable is in the following format:-
       Foo::bar() = array('Foo', 'bar')
       $foo->bar = array($foo, 'bar')
       myfunction() = 'myfunction'

- The name of the classes are Modulename_$type (case sensitive).
  The $func argument would be the public methods contained therein.
  Also see the EventHandlers folder which shows how a method can be
  added to the controller via a notifyUntil() events of name
  'controller.method_not_found' and 'controllerapi.method_not_found'
  for APIs.

- OO modules will initialise an autoloader for the module automatically so
  a call to a class Example_DBObject_Users would load
  module/Example/lib/Example/DBObject/Users.php - the class contained should be
  Example_DBObject_Users.

  Please note that because of the use of ModUtil::func() and ModUtil::apiFunc()
  Controller and Controller Apis must be named according to the type in real
  camel case (ucwords).  E.g. type = adminform means the file *must* be names
  Adminform and NOT AdminForm.  The class name would be Modulename_Adminform.

- You may now optionally include bootstrap.php in your module root directory.
  This will be loaded during ModUtil::load/ModUtil::loadGeneric() automatically.

- You may additionally register autoloaders with
  ZLoader::addAutoloader($namespace, $path) where
  $namespace is the first part of the PEAR classname, and $path is
  the path to the containing folder.  Use bootstrap.php.

API CHANGES
===========
There is a shell script in SVN tool/ to rename all these for you automatically
and accurately.

- pnMod* now all deprecated see ModUtil::*
- pnUser* deprecated, see UserUtil::*
- pnBlock deprecated, see BlockUtil::*
- pn* deprecated see System::*
- Legacy APIs for BC are stored in legacy/Compat.php and legacy/Api.php

- The prefixes are NOT gone for the class function based controllers like pnadmin etc.
  This is deliberate to encourage you to move to OO module controllers.


WORKFLOW CHANGES
================
- If you use WorkflowUtil, there are four changes for Zikula 1.3:
   - getActionsByStateArray:
       is not deprecated.
   - getActionsByState:
       now returns all the action data as array($action.id => $action),
       instead of array(id => id).
   - getActionTitlesByState:
       useful method to build the buttons for the current state,
       returning the allowed actions as array($action.id => $action.title).
   - getActionsForObject:
       now returns the result of getActionsByState.
   If you used values, replace them with the result keys, and take advantage
   of the action data now available.

JAVASCRIPT CHANGES
==================
The old way of giving ajax errors was  lacking, it did not use JSON to return
information to the calling JS. For this reason the AjaxUtil::error() function has
been re-written. This re-write breaks backwards compatibility so all system/other
modules which make use of ajax will have to be updated to the method. this sounds
like a pain but it is really quite easy.

This is the stub for AjaxUtil::error() php function:

    function error($message = '', $other = array(), $createauthid = false, $displayalert = true, $code = '400 Bad data')

The first parameter is $messageis the message that will be displayed in the alert popup to the user.

  - $other is an associative array of other data you may wish to return in json format.

  - $createauthid will update authid's if set to true. This should only be used in cases
where the error is not being called because of a security/authid issue. If you have
an error where the data is bad, probably good to update authid's so the user can try
again. However, if the user failed an authid check in your modules ajax.php do not set
this to true because it will issue them a new good authid, thus undermining the entire
CRSF protection.

  - $displayalert triggers an alert to be shown to the user via the JS function
    which matches up with this php function.
  - $code is the code to send back in the header of the response, this should
    match html status codes, check here http://en.wikipedia.org/wiki/List_of_HTTP_status_codes

One AjaxUtil::error() has been issued from the php side, the error will need to
be caught on the javascript side. There is a new javascript library function for
this purpose called Zikula.ajaxResponseError(transport, supresserror).

This JavaScript function has two parameters, the first is the transport itself,
do not dejson the transport before handing it to this function, it will do that
itself. The second is a boolean option to supress error reporting (don't show an
alert box): Normally showing of an alert box is handled by the php AjaxUtil::error()
function as detailed above ($displayalert), but the 'supresserror' argument will override
that. This allows the PHP function to specify if an alert should be shown in the javascript,
but also allows the javascript to ignore what the php tells it to do. This javascript
function returns the dejson'd data.

Here is an example of its use taken from the admin panel.
ajax.php file in admin module, function to edit category name

    public function editCategory()
    {
        //get form values
        $cid = trim(FormUtil::getPassedValue('cid'));
        $cat = trim(FormUtil::getPassedValue('catname'));

        //security checks
        if (!SecurityUtil::checkPermission(...)) {
            LogUtil::registerPermissionError(null,true);
            return AjaxUtil::error();
        }

        if (!SecurityUtil::confirmAuthKey()) {
            LogUtil::registerAuthidError();
            return AjaxUtil::error();
        }

        //make sure cid and category name (cat) are both set
        if (!isset($cid) || $cid == '' || !isset($cat) || $cat == '') {
            LogUtil::registerArgsError();
            return AjaxUtil::error(null, array(), true);
        }

        //... rest of function
    }

We see that first security checks are made, and an error is called if the checks
fail, the authids are not updated because it is a security error. The there is a
check to see if the cid and category name are set. If they are not, an error is
called, but this time the third parameter to AjaxUtil::error() is set to true,
meaning authid's are set.

The json data sent back to the calling javascript will include:

    "errormessage" => whatever LogUtil::registerArgsError() returned
    "authid" => a new authid
    "displayalert" => 1 (because this is the default value)

Now let us look at the admin_admin_ajax.js file: this is the javascript file which
issued the initial request and handles the response. The following is the callback
function called when the JS receives its ajax response.

    onComplete: function(transport, element) {
        // response is not good
        if(transport.status != 200 ) {
            // call the ajaxResponseError function and hand it the transport
            // an alert will be displayed because displayalert => '1' from the php
            // the authid will be updated because "authid" exists in the json data from the php function
            json = Zikula.ajaxResponseError(transport);

            // we can now do anything else we want to do
            // this update to the authid is only here because the admin module
            // has a special way of dealing with autids... it has been leftonly
            // to demonstrate that the json data is returned and can be
            // used after the ajaxResponseError function.

            document.getElementById('admintabsauthid').value = json.authid;
            return;
        }

        var json = pndejsonize(transport.responseText);
        // response is good... do whatever we want
    }

PAGEADDVAR CHANGES
==================
This Api has been updated with several conveniences.  The changes are
fully BC but you will notice the included sources are changes to the new ones
despite the old references.

Prototype and Scriptaculous have been combined into a single compressed file for
convenience.  Only validation.js and unittest.js have not been combined.

Simply including prototype will include the combined version.  There is no need
to specify ajax, prototype and scriptaculous separately any more,
simply just specify 'prototype'.

To add Livepipe, simply specify 'livepipe'.  All Livepipe files have been
compressed into one.

To add jQuery, simply specify 'jquery'.  This will set up jQuery.noConflict()
automatically.


ZIKULA_VIEW / ZIKULA_THEME CLASSES
==================================
Dozens of getter and setters have been added to try and encapsulate things more and
one day, allow a more easy migration away from Smarty 2.  Please desist from
direct access to properties and use the getter/setters.