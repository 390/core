ZIKULA HOOKS
============
This document describes the Zikula Hook system.

What is a hook?
---------------
A hook is just another kind of event that occurs in Zikula and should really be called
'hookable events'.  Unlike events, hookable events are used to attach modules/plugins to
other modules so that they can UI functionality and are completely configurable by the 
site administrator in that the administrator can choose which modules are hooks onto
which, and what order they are executed in.  For example, a comments module could
attach comments to a blog module.  Similarly a ratings module could be attached to a
blog module, so that all articles would have now have ratings.

Other examples could be adding extra fields to forms to gather extra information.

Providers and Subscriber
------------------------
In this document we will use "hook providers", and "hook subscribers".  A provider is simply
a module/plugin that actually provides some functionality that can be attached to other
modules's output.

A subscriber is simply a module that understands hooks.  It can process hooks that are
provided by other modules.

Areas
-----
This is an advanced feature for complex modules.  In general, modules will only provide
or subscribe to one area.  Areas allow subscribers and provider to group their features.
This is to allow modules to provide different groups of hooks.  From the provider
side, a it can provide different hook features.  From the subscriber side, it allows a
module to apply hooks to one part of a module as opposed to another.

Areas should all be unique, so please use this format:

    modulehook_area.mymodule.<areaname>
    modulehook_area.comments.general (the provider area)
    modulehook_area.news.articles    (the subscriber area)

Subscriber Modules
------------------
Modules that understand hooks must make this known to the Zikula framework the
modules's Version.php.  This is done by adding a method called to Version.php

    protected function setupHookBundles()
    {
        $bundle = new Zikula_Version_HookSubscriberBundle('modulehook_area.news.articles', $this->__('News Display Hooks'));
        $bundle->addType('ui.view', 'news.hook.ui.view');
        $bundle->addType('ui.create', 'news.hook.ui.create');
        $this->registerHookSubscriberBundle($bundle);
    }

During installation or upgrade of the module you must register the bundles with the
persistence layer using:

    HookUtil::registerHookSubscriberBundles($this->version);

A complex module might have several different areas where attaching Hooks may or
may not be appropriate, or may require different Hooks for different areas.
This is why you may specify different areas in the API.  Each area would have to
have it's own set of unique event names.

The addType() method deserves some explanation.  The first parameter is the hook
type; the second parameter is the event name that is triggered by *THIS* module.
So if this module was a news module, then these are the unique names that only
*this* news module actually triggers.  Under the hood, when a user attaches say
a comments module (provider), then the hook handler of the comment module will be
attached to the EventManager using the event name supplied by the subscriber module
(news). e.g. attach news.ui.view to comments.handler.ui.view which is the name of a
callable handler registered by the hook provider (news).

It is also necessary to add the following to the getMetaData() method of Version.php
to let Zikula know that the module understands Hooks and may subscribe to them.
Zikula will add a configuration menu to the administration area of the module.  For
this reason you *must* have an admin controller in the module.

    $meta['capabilities'] = array(HookUtil::SUBSCRIBER_CAPABLE => array('enabled' => true));

Provider Modules
----------------
Provider modules must make their available hook handlers known to Zikula.  You must perform three
tasks:

Firstly add the hook_provider capability to the module's Version.php in getMetaData()

    $meta['capabilities'] = array(HookUtil::PROVIDER_CAPABLE => array('enabled' => true));

Secondly, you must configure provider bundles in the Version.php by adding the following method
to Version.php

    protected function setupHookBundles()
    {
        $bundle = new Zikula_Version_HookProviderBundle('modulehook_area.ratings.item', $this->__('Ratings Hook Poviders'));
        $bundle->addHook('hookhandler.ratings.ui.view', 'Ratings', 'ui.view', 'Ratings_Hooks', 'uiview');
        //...
        $this->registerHookProviderBundle($bundle);

        //... repeat as many times as necessary
    }

Thirdly, installation or upgrade of the module you must register the bundles with the
persistence layer using:

    HookUtil::registerHookProviderBundles($this->version);

This will register the hook event handlers, that is to say, the actual PHP class/method
that will respond to hook events that are triggered by subscriber modules.

A module may register either static class callable methods, like Foo::Bar($event) or
services (which are instanciated class objects).  If using services, they must be 
instances of Zikula_EventHandler.  We use one API do register this.

Leaving $serviceId = null, will tell Zikula the callable is a static class method.
If you give a $serviceId, then this class will be instanciated and used.  This means
you can use the same $serviceId and have multiple methods in side if you wish.

The $name of the hook, is the name of the handler - a common name.  This is NOT
an event name.

    $bundle->addHook($name, $owner, $type, $className, $method, $serviceId, $weight);

    // registering a static method handler.
    $bundle->addHook('hookhandler.ratings.ui.view', 'Ratings', 'ui.view', 'Ratings_Hooks', 'uiview');

    // registering a service
    $bundle->addHook('hookhandler.ratings.ui.view', 'Ratings', 'ui.view', 'Ratings_Hooks', 'uiview', 'module.ratings_hooks');

The $weight parameter can be used to set default weights of handlers that are
eventually attached with EventManager.  Generally, this parameter can be left alone.

Hook Types
----------
The following is a list of valid hook types.  Not all have to be used but in general,
a HookBundle should contain at least the ui.* and process.* handlers valid to complete
an action.

ui.view          - Display hook for view/display templates.
ui.edit          - Display hook for create/edit forms.
validate.update  - Used to validate input from an ui create/edit form.
process.update   - Perform the final update actions for a ui create/edit form.
process.delete   - Perform the final delete actions for a ui form.

Hookable Events
---------------
In this section we will discuss the actual hookable event that is triggered by
a subscriber module.

The event encapulates information about the hookable event.  Principally, we need
the hook event name, e.g. 'news.hook.ui.create'.  We generally prefix with the
name of the owner of the event (the owning module).

Next, we need the subject of the event.  This will be the object or array of data.
For example if this was a blog post, then it would be the blog post object (if
using Doctrine or the array of the blog post).  Please note you need this in all
cases except for create where there is no data yet, or if there is, it's an empty
object.  This goes for delete operations also.  This might not make sense at first
look, but even delete operations normally come from a screen that has displayed
the post to be deleted, therefor, this object should already be available.

In the arguments of the event, we should also include an array of
'module' => $moduleName,
'id'     => the id field of this array, or ID property of the object

It might looks like this:

    new Zikula_Event('news.hook.process.update', $article, array('module' => 'News', 'id' => 'id'));

In general, hook providers can assume if no 'id' key is available that the ID 
is 'id' as this is generally logical and good practice.

Implementing Hooks from the Subscriber Side
-------------------------------------------
So it can be seen quite clearly that Hooks are really only for use on with display.  Their
main purpose it so a module can be attached to another, like attaching ratings to blog
posts.  In this section we cover the implementation of hooks from the subscriber's side.
So in our example, that would mean the Blogging module.

We don't need to be concerned with attaching hooks to modules, that is handled automatically
by the administation UI.

Attaching display hooks is very simple.  Inside the template simply add

    {notifydisplayhooks eventname='news.hook.ui.view' subject=$subject module=$module assign='display_hooks'}

$module will be added magically unless you need to specify it (the value is take from
the Zikula_View instance.

The plugin will return all display hooks, sorted according to the administration
settings.  The return is an array of

    array('moduleName1' => 'output1',
          'moduleName2' => 'output2');

In the module controllers, you will need to implement the process and or validation
hook types.  This can be done as follows:

    // the long way
    $event = new Zikula_Event('news.hook.process.create', $subject, array('module' => $moduleName));
    $this->eventManager->notify($event);

   // the short way, provided in instances of Zikula_Base (controllers, APIs etc).
   $this->notifyHooks('news.hook.process.create', $subject);

HOOK RESPONSES FROM PROVIDERS
-----------------------------
A hook handler should response with a Zikula_Response_DisplayHook object in the following manner.

    public function hookHandler(Zikula_Event $event)
    {
        $name = 'Foo'; // this module's name.
        $template = 'template_name.tpl'; // the name of the module's template
        $view = Zikula_View::getInstance($name);

        // do stuff...

        // add this response to the event stack
        $event->data[$name] = new Zikula_Response_DisplayHook($name, $view, $template);
    }
